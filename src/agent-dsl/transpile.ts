#!/usr/bin/env bun
// Transpiler: import author once, build descriptor tree, and emit direct Rx TypeScript.

import { mkdirSync, writeFileSync } from "node:fs";
import { dirname, relative, resolve } from "node:path";
import { pathToFileURL } from "node:url";

type Program = { name: string; build: () => any; policies: any[] };
type Loc = { file: string; line: number; col: number };
type Desc = any & { __op?: string; loc?: Loc };

type EmitCtx = { nextId: number };
type CodeExpr = { __isCode: true; code: string };

function usage(): never {
  console.error("usage: bun run src/agent-dsl/transpile.ts <author.ts> --out <out.ts>");
  process.exit(1);
}

const args = process.argv.slice(2);
if (args.length < 1) usage();
const inPath = resolve(process.cwd(), args[0]!);
const outIdx = args.indexOf("--out");
if (outIdx === -1 || !args[outIdx + 1]) usage();
const outPath = resolve(process.cwd(), args[outIdx + 1]!);

const authorModURL = pathToFileURL(inPath).href;

const mod = await import(authorModURL).catch((e) => {
  console.error("Failed to import author module:", e);
  process.exit(2);
});

const prog: Program = mod.default;
if (!prog || typeof prog.build !== "function" || !Array.isArray(prog.policies)) {
  console.error("Default export must be a Program with build() and policies[].");
  process.exit(3);
}

const root: Desc = prog.build();

const outDir = dirname(outPath);
mkdirSync(outDir, { recursive: true });

const relRuntimeImport = normalizeRelative(dirname(outPath), resolve(process.cwd(), "src/runtime/index.ts"));

const codeBody = emitRoot(root);
const wrapped = wrapWithPolicies(codeBody, prog.policies);

const fileSrc = `// AUTO-GENERATED by agent-dsl transpiler (PoC)
import type { Runtime, Ctx } from ${JSON.stringify(relRuntimeImport)};

export async function main(R: Runtime, ctx: Ctx) {
${wrapped}
}
`;

writeFileSync(outPath, fileSrc, "utf8");
console.log(`Generated: ${outPath}`);

// ---------- helpers ----------

function normalizeRelative(fromDir: string, toFile: string): string {
  let rel = relative(fromDir, toFile);
  if (!rel.startsWith(".")) rel = "./" + rel;
  return rel.split("\\").join("/");
}

function locStr(n?: Desc): string {
  if (!n || !n.loc) return "<unknown>";
  return `${n.loc.file}:${n.loc.line}:${n.loc.col}`;
}

function eEmit(msg: string, n?: Desc): never {
  throw new Error(`E_EMIT: ${msg} @ ${locStr(n)}`);
}

function fresh(prefix: string, ctx: EmitCtx): string {
  return `${prefix}${ctx.nextId++}`;
}

function emitRoot(node: Desc): string {
  const ctx: EmitCtx = { nextId: 0 };
  const [code, varName] = emitObservable(node, ctx);
  return `${code}\n  return ${varName};`;
}

function emitObservable(node: Desc, ctx: EmitCtx): [string, string] {
  if (!node || typeof node !== "object") eEmit("node is not an object", node);
  switch (node.__op) {
    case "seq": {
      const steps: Desc[] = node.steps || [];
      if (steps.length === 0) eEmit("empty seq not supported", node);
      let [code, curr] = emitObservable(steps[0], ctx);
      for (let i = 1; i < steps.length; i++) {
        const st = steps[i];
        if (st && st.__op === "andThen") {
          const v = fresh("v", ctx);
          const callExpr = emitAndThenCall(st, v);
          const next = fresh("s", ctx);
          code += `\n  const ${next} = R.flatMap(${curr}, (${v}) => ${callExpr}, "concat");`;
          curr = next;
        } else if (st && st.__op === "log") {
          const next = fresh("s", ctx);
          const label = JSON.stringify(st.label);
          code += `\n  const ${next} = R.tap(${curr}, (v) => ctx.log({ label: ${label}, v }));`;
          curr = next;
        } else {
          const [ic, iv] = emitObservable(st, ctx);
          const next = fresh("s", ctx);
          code += `\n${ic}\n  const ${next} = R.flatMap(${curr}, () => ${iv}, "concat");`;
          curr = next;
        }
      }
      return [code, curr];
    }
    case "par": {
      const steps: Desc[] = node.steps || [];
      const thunks = steps.map((s) => `() => ${emitInlineExpr(s, ctx)}`);
      const v = fresh("s", ctx);
      const code = `  const ${v} = R.par([ ${thunks.join(", ")} ]);`;
      return [code, v];
    }
    case "join": {
      const steps: Desc[] = node.steps || [];
      const exprs = steps.map((s) => emitInlineExpr(s, ctx));
      const v = fresh("s", ctx);
      const code = `  const ${v} = R.zip(${exprs.join(", ")});`;
      return [code, v];
    }
    case "aliasCall": {
      const v = fresh("s", ctx);
      const call = emitAliasCall(node);
      const code = `  const ${v} = ${call};`;
      return [code, v];
    }
    case "useTool": {
      const v = fresh("s", ctx);
      const call = emitUseTool(node);
      const code = `  const ${v} = ${call};`;
      return [code, v];
    }
    default:
      eEmit(`unsupported node ${String(node.__op)}`, node);
  }
}

function emitInlineExpr(node: Desc, ctx: EmitCtx): string {
  if (!node || typeof node !== "object") eEmit("node is not an object", node);
  switch (node.__op) {
    case "aliasCall":
      return emitAliasCall(node);
    case "useTool":
      return emitUseTool(node);
    case "par": {
      const steps: Desc[] = node.steps || [];
      const thunks = steps.map((s) => `() => ${emitInlineExpr(s, ctx)}`);
      return `R.par([ ${thunks.join(", ")} ])`;
    }
    case "join": {
      const steps: Desc[] = node.steps || [];
      const exprs = steps.map((s) => emitInlineExpr(s, ctx));
      return `R.zip(${exprs.join(", ")})`;
    }
    default:
      const [code, v] = emitObservable(node, ctx);
      return `(function(){\n${code}\n    return ${v};\n  })()`;
  }
}

function emitAliasCall(node: Desc): string {
  const name = (node as any).name as string;
  const args = (node as any).args as any[];
  const parts = args.map(emitValue);
  return `ctx.tools.${name}(${parts.join(", ")})`;
}

function emitUseTool(node: Desc): string {
  const spec = (node as any).spec as any;
  if (spec && spec.kind === "log") {
    return `ctx.tools.log(${emitValue(spec)})`;
  }
  const kind = spec && spec.kind ? JSON.stringify(spec.kind) : '""';
  return `ctx.tools[${kind}](${emitValue(spec)})`;
}

function emitAndThenCall(andThenNode: Desc, bindingVar: string): string {
  const f = (andThenNode as any).f as Function;
  const placeholder = new Proxy([], {
    get(_t, prop) {
      if (prop === Symbol.iterator) {
        return function* () {
          let i = 0;
          while (i < 16) {
            yield code(`${bindingVar}[${i}]`);
            i++;
          }
        };
      }
      if (typeof prop === "string" && /^\d+$/.test(prop)) {
        return code(bindingVar + `[${prop}]`);
      }
      return undefined;
    },
  });
  const ret = f(placeholder);
  if (!ret || typeof ret !== "object" || ret.__op !== "aliasCall") {
    eEmit("andThen must return an alias/registry call", andThenNode);
  }
  return emitInlineExpr(ret, { nextId: 0 });
}

function code(expr: string): CodeExpr {
  return { __isCode: true, code: expr } as CodeExpr;
}

function isCode(x: any): x is CodeExpr {
  return !!x && x.__isCode === true;
}

function emitValue(v: any): string {
  if (isCode(v)) return v.code;
  if (v === null) return "null";
  const t = typeof v;
  if (t === "undefined") return "undefined";
  if (t === "string") return JSON.stringify(v);
  if (t === "number" || t === "boolean") return String(v);
  if (Array.isArray(v)) return `[${v.map(emitValue).join(", ")}]`;
  if (t === "object") {
    const entries = Object.entries(v as Record<string, any>);
    const props = entries.map(([k, val]) => `${safeKey(k)}: ${emitValue(val)}`);
    return `{ ${props.join(", ")} }`;
  }
  eEmit("unsupported value in arguments");
}

function safeKey(k: string): string {
  return /^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(k) ? k : JSON.stringify(k);
}

function wrapWithPolicies(body: string, policies: any[]): string {
  const m = body.match(/return\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*;\s*$/);
  if (!m) return body;
  let varName = m[1]!;
  let prefix = body.replace(/\s*return\s+[a-zA-Z_$][a-zA-Z0-9_$]*\s*;\s*$/, "");
  let wrap = varName;
  for (const p of policies || []) {
    if (p && p.__policy === "retry") {
      wrap = `R.retry(${wrap}, ${emitValue(p.cfg)})`;
    } else if (p && p.__policy === "recover") {
      const handler = (p as any).handler as Function;
      const ret = handler(code("e"));
      if (!ret || typeof ret !== "object") {
        eEmit("recover handler must return a descriptor", p as any);
      }
      const expr = emitInlineExpr(ret as Desc, { nextId: 0 });
      wrap = `R.onError(${wrap}, (e) => ${expr})`;
    }
  }
  const finalVar = `_final`;
  prefix += `\n  const ${finalVar} = ${wrap};\n  return ${finalVar};`;
  return prefix;
}
