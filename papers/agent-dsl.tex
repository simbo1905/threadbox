\documentclass[11pt,a4paper]{article}
\usepackage[margin=1in]{geometry}
\usepackage{inconsolata}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{listings}
\hypersetup{colorlinks=true, linkcolor=black, urlcolor=blue, citecolor=black}
\title{Threadbox Agent DSL:\\ An Imperative Builder for Deterministic Agent Orchestration}
\author{Simon Massey}
\date{\today}
\begin{document}\maketitle
\begin{abstract}
We present an imperative TypeScript DSL that builds a topographical plan as an intermediate representation (IR), validates it against a registered tool/agent ABI, transpiles it to executable code, and dynamically loads the result. Agents are just constrained calls; we support a typed blackboard and bounded, epochal re-entry instead of unstructured loops—yielding deterministic, auditable, budgeted execution.
\end{abstract}
\section{Motivation}
Orchestrators often hard-code a single worldview (pure DAGs, chat loops, or state machines). We propose a unifying substrate: a builder API that emits an IR for validation, transpilation, and execution. This supports fixed plan$\rightarrow$execute and blackboard-centric, bounded replanning without agent soup. See related engineering write-ups that informed the design.%
\footnote{Related patterns overviews and state-machine framings.}
\section{System Overview}
\textbf{Build $\rightarrow$ Validate $\rightarrow$ Transpile $\rightarrow$ Load $\rightarrow$ Run}. The builder composes topology (\texttt{seq}, \texttt{inParallel}, \texttt{andThen}, \texttt{join}) and policies (\texttt{onFailureRetry}, \texttt{recover}) into IR descriptors; a validator checks registration, schemas, budgets; the transpiler emits executable code; the runtime executes with tracing and append-only logging.
\section{Execution Model}
\textbf{Primitives:} sequencing/parallelism with joins; \texttt{call\{tool|api|agent\}} sites with registered IO schemas and budgets; \texttt{validate(...)} gates; policy nodes for retry/recover; and a typed, append-only \textbf{blackboard}. "Programs call programs" via \texttt{call\{agent\}} with a whitelisted context.
\section{Epochal Re-Entry (Bounded Replanning)}
Re-entry is encoded as epochs with a strictly decreasing measure (e.g., remaining tasks). If the measure fails to decrease or budgets expire, route to final validation and emit a non-convergence outcome.
\section{Tool/Agent ABI}
A registry maintains id/kind/version, IO schemas, capabilities; the loader wires implementations; the validator rejects missing/incompatible calls; tracing captures usage/health.
\section{Observability and Durability}
Each action appends start/finish/failure events; policies emit retry/backoff; blackboard writes are immutable entries for replay and provenance.
\section{Example}
The \emph{risk pipeline} shows parallel fetch, assessment, and logging with retry/recover—topology-first, then validated/transpiled.
\section{Status}
Early PoC: builder$\rightarrow$IR$\rightarrow$validator$\rightarrow$transpiler prioritized; storage/connectors are supporting infra.
\section{Conclusion}
A checkable IR, constrained composition, a typed blackboard, and bounded epochs yield a general yet disciplined substrate for agentic workloads—production-first and replayable.
\end{document}