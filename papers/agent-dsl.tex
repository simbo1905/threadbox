\documentclass[11pt,a4paper]{article}
\usepackage[margin=1in]{geometry}
\usepackage{inconsolata}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{listings}
\hypersetup{colorlinks=true, linkcolor=black, urlcolor=blue, citecolor=black}
\title{Threadbox Agent DSL:\\ An Imperative Builder for Deterministic Agent Orchestration}
\author{Simon Massey}
\date{\today}
\begin{document}\maketitle
\begin{abstract}
We present an imperative TypeScript DSL that builds a topographical plan as an intermediate representation (IR), validates it against a registered tool/agent ABI, transpiles it to executable code, and dynamically loads the result. Agents are just constrained calls; we support a typed blackboard and bounded, epochal re-entry instead of unstructured loops—yielding deterministic, auditable, budgeted execution.
\end{abstract}
\section{Motivation}
Orchestrators often hard-code a single worldview (pure DAGs, chat loops, or state machines). We propose a unifying substrate: a builder API that emits an IR for validation, transpilation, and execution. This supports fixed plan$\rightarrow$execute and blackboard-centric, bounded replanning without agent soup. See related engineering write-ups that informed the design.%
\footnote{Related patterns overviews and state-machine framings.}
\section{System Overview}
\textbf{Build $\rightarrow$ Validate $\rightarrow$ Transpile $\rightarrow$ Load $\rightarrow$ Run}. The builder composes topology (\texttt{seq}, \texttt{inParallel}, \texttt{andThen}, \texttt{join}) and policies (\texttt{onFailureRetry}, \texttt{recover}) into IR descriptors; a validator checks registration, schemas, budgets; the transpiler emits executable code; the runtime executes with tracing and append-only logging.
\section{Execution Model}
\textbf{Primitives:} sequencing/parallelism with joins; \texttt{call\{tool|api|agent\}} sites with registered IO schemas and budgets; \texttt{validate(...)} gates; policy nodes for retry/recover; and a typed, append-only \textbf{blackboard}. "Programs call programs" via \texttt{call\{agent\}} with a whitelisted context.
\section{Epochal Re-Entry (Bounded Replanning)}
Re-entry is encoded as epochs with a strictly decreasing measure (e.g., remaining tasks). If the measure fails to decrease or budgets expire, route to final validation and emit a non-convergence outcome.
\section{Tool/Agent ABI}
A registry maintains id/kind/version, IO schemas, capabilities; the loader wires implementations; the validator rejects missing/incompatible calls; tracing captures usage/health.
\section{Observability and Durability}
Each action appends start/finish/failure events; policies emit retry/backoff; blackboard writes are immutable entries for replay and provenance.
\section{Example}
The \emph{PDF processing pipeline} demonstrates a three-stage document transformation workflow using the agent DSL. The pipeline: (1) extracts individual pages from a PDF document, (2) applies text cleanup and enhancement to each page in parallel, and (3) joins the processed pages into a cohesive text document. This showcases sequential composition with parallel processing, error recovery, and the typed blackboard for intermediate state management.

\begin{lstlisting}[language=JavaScript, basicstyle=\ttfamily\small, frame=single]
import { program, seq, inParallel, andThen, join, 
         onFailureRetry, recover, useTool, log } from "agent-dsl";
import { callApi, runShell } from "../src/actions";

export default program("PDF_PROCESSING", () =>
  seq(
    // Stage 1: Extract PDF into individual page files
    callApi("extractPdfPages", { inputPath: "document.pdf" }),
    
    // Stage 2: Process each page in parallel
    andThen(({ pages }) => 
      inParallel(
        ...pages.map(page => 
          seq(
            callApi("extractTextFromPage", { page }),
            andThen(({ rawText }) => 
              callApi("tidyText", { 
                text: rawText,
                operations: ["removeExtraWhitespace", 
                           "fixLineBreaks", 
                           "correctOCRErrors"]
              })
            )
          )
        )
      )
    ),
    
    // Stage 3: Join processed pages into final document
    andThen((processedPages) => 
      callApi("joinTextPages", { 
        pages: processedPages,
        format: "markdown",
        addPageBreaks: true
      })
    ),
    
    log("pdf-processing-complete")
  )
).with(
  onFailureRetry({ max: 2, backoffMs: 1000 }),
  recover(e => useTool({ 
    kind: "log", 
    level: "error", 
    message: `PDF processing failed: ${e.message}` 
  }))
);
\end{lstlisting}

This example illustrates the DSL's ability to compose complex workflows with clear separation of concerns, automatic parallelization where beneficial, and robust error handling throughout the pipeline.
\section{Status}
Early PoC: builder$\rightarrow$IR$\rightarrow$validator$\rightarrow$transpiler prioritized; storage/connectors are supporting infra.
\section{Conclusion}
A checkable IR, constrained composition, a typed blackboard, and bounded epochs yield a general yet disciplined substrate for agentic workloads—production-first and replayable.
\end{document}